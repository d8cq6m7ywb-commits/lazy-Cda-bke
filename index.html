    currentFitData = null;
  };
  reader.readAsArrayBuffer(file);
}

function toNumber(x){
  const v = (typeof x === "object" && x !== null && "value" in x) ? x.value : x;
  const n = Number(v);
  return isFinite(n) ? n : null;
}

function normaliseRecord(r){
  const speed = toNumber(r.speed) ?? toNumber(r.enhanced_speed) ?? null;
  const dist  = toNumber(r.distance) ?? toNumber(r.total_distance) ?? null;
  const alt   = toNumber(r.altitude) ?? toNumber(r.enhanced_altitude) ?? null;
  const power = toNumber(r.power) ?? 0;
  const cadence = toNumber(r.cadence);
  const ts = r.timestamp ? new Date(r.timestamp) : null;

  return {
    t: ts,
    distance: dist,
    speed: speed,
    altitude: alt,
    power: power,
    cadence: cadence,
    grade: 0
  };
}

function addGradeFromAlt(records){
  if (!records || records.length < 2) return;
  for (let i = 1; i < records.length; i++){
    const r0 = records[i-1], r1 = records[i];
    const d_m = (r1.distance != null && r0.distance != null) ? (r1.distance - r0.distance) : 0;
    const dz_m = (r1.altitude != null && r0.altitude != null) ? (r1.altitude - r0.altitude) : 0;
    r1.grade = (d_m > 1) ? (dz_m / d_m) : 0;
  }
  records[0].grade = records[1].grade;
}

/**
 * SUPER-ROBUST normaliser:
 * Recursively collects every `records` / `record` array anywhere in the parsed FIT object,
 * then builds one synthetic lap containing all records.
 */
function normaliseFitDataFromFitParser(data){
  function collectAllRecords(node, out){
    if (!node || typeof node !== "object") return;
    if (Array.isArray(node)){
      for (const item of node) collectAllRecords(item, out);
      return;
    }
    for (const key in node){
      if (!Object.prototype.hasOwnProperty.call(node, key)) continue;
      const val = node[key];
      if ((key === "records" || key === "record") && Array.isArray(val)){
        out.push(...val);
      } else {
        collectAllRecords(val, out);
      }
    }
  }

  const rawRecords = [];
  collectAllRecords(data, rawRecords);

  const records = rawRecords.map(normaliseRecord);
  if (records.length){
    addGradeFromAlt(records);
  }

  const laps = [];

  if (records.length){
    const first = records[0];
    const last  = records[records.length - 1];

    let totalDistance = null;
    if (last.distance != null){
      if (first.distance != null && last.distance >= first.distance){
        totalDistance = last.distance - first.distance;
      } else {
        totalDistance = last.distance;
      }
    }

    let totalTimerTime = null;
    if (first.t && last.t){
      totalTimerTime = (last.t - first.t) / 1000; // seconds
    }

    let sumP = 0, nP = 0;
    for (const r of records){
      if (r.power != null && isFinite(r.power)){
        sumP += r.power;
        nP++;
      }
    }
    const avgPower = nP ? sumP / nP : null;

    laps.push({
      index: 0,
      displayIndex: 1,
      use: true,
      totalDistance: totalDistance,
      totalTimerTime: totalTimerTime,
      avgSpeed: null,
      avgPower: avgPower,
      records: records
    });
  }

  return { laps, records };
}

function renderLapTable(laps){
  const body = document.getElementById("lapTableBody");
  if (!body) return;
  body.innerHTML = "";
  if (!laps || !laps.length){
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 6;
    td.textContent = "No laps found in file.";
    td.style.textAlign = "center";
    tr.appendChild(td);
    body.appendChild(tr);
    return;
  }

  const maxDist = Math.max(...laps.map(l => l.totalDistance || 0));

  laps.forEach(lap => {
    const tr = document.createElement("tr");
    const distKm = lap.totalDistance != null ? (lap.totalDistance / 1000) : null;
    const timeMin = lap.totalTimerTime != null ? (lap.totalTimerTime / 60) : null;
    const useDefault = !maxDist || (lap.totalDistance && lap.totalDistance > 0.3*maxDist);

    let lapSpeedKmh = null;
    if (distKm != null && timeMin != null && timeMin > 0.01) {
      lapSpeedKmh = distKm / (timeMin / 60);
    } else if (lap.avgSpeed != null) {
      lapSpeedKmh = lap.avgSpeed * 3.6;
    }

    tr.innerHTML = `
      <td>${lap.displayIndex}</td>
      <td><input type="checkbox" class="lap-use" data-lap-index="${lap.index}" ${useDefault ? "checked" : ""}></td>
      <td>${distKm != null ? distKm.toFixed(2) : "–"}</td>
      <td>${timeMin != null ? timeMin.toFixed(1) : "–"}</td>
      <td>${lapSpeedKmh != null && isFinite(lapSpeedKmh) ? lapSpeedKmh.toFixed(1) + " km/h" : "–"}</td>
      <td>${lap.avgPower != null ? lap.avgPower.toFixed(0) + " W" : "–"}</td>
    `;
    body.appendChild(tr);
  });
}

function runFitAnalysis(){
  const statusEl = document.getElementById("fitStatus");
  const summaryEl = document.getElementById("fitSummary");
  const statsTable = document.getElementById("fitStatsTable");
  const statsBody = document.getElementById("fitStatsBody");

  if (!currentFitData){
    statusEl.textContent = "No FIT file parsed yet.";
    return;
  }

  const mode = document.getElementById("analysisMode").value;
  const env = getEnvParamsForSamples();
  const config = {
    minSpeedKmh: 10,
    maxSpeedKmh: 65,
    minPowerW: 80,
    maxPowerW: 900,
    maxAbsGrade: 0.06,
    minCdA: 0.10,
    maxCdA: 0.50
  };

  let records = [];

  if (mode === "laps"){
    // Only use selected laps
    const checkboxes = document.querySelectorAll(".lap-use");
    const idxSet = new Set();
    checkboxes.forEach(cb => {
      if (cb.checked){
        const idx = Number(cb.getAttribute("data-lap-index"));
        idxSet.add(idx);
      }
    });
    currentFitData.laps.forEach(lap => {
      if (idxSet.has(lap.index)){
        records.push(...lap.records);
      }
    });
  } else {
    // Race mode: ignore selection, use whole file
    records = currentFitData.records.slice();
  }

  if (!records.length){
    statusEl.textContent = "No records in selected laps.";
    return;
  }

  const analysis = analyseCdAFromRecords(records, env, config);
  renderFitAnalysis(analysis, summaryEl, statsTable, statsBody);
  statusEl.textContent = `Used ${analysis.countAll} samples after filtering.`;
  renderFitScatter(analysis.points);
}

function isUsableRecord(rec, cfg){
  if (rec.speed == null || rec.power == null) return false;
  const v_kmh = rec.speed * 3.6;
  const p = rec.power;
  const grade = rec.grade || 0;
  if (!isFinite(v_kmh) || v_kmh < cfg.minSpeedKmh || v_kmh > cfg.maxSpeedKmh) return false;
  if (!isFinite(p) || p < cfg.minPowerW || p > cfg.maxPowerW) return false;
  if (!isFinite(grade) || Math.abs(grade) > cfg.maxAbsGrade) return false;
  return true;
}

function computeCdAForRecord(rec, env){
  const v_g = rec.speed;
  const v_air = Math.max(0, v_g + env.windMs);
  if (v_g <= 0 || v_air <= 0) return NaN;

  const grade = rec.grade || 0;
  const cosTheta = 1/Math.sqrt(1 + grade*grade);
  const m = env.totalMass;
  const g = env.g;
  const crr = env.crr;
  const powerAtWheel = env.powerAtWheelFactor * rec.power;

  const pRoll = g*m*crr*cosTheta*v_g;
  const pClimb = g*m*grade*v_g;
  const pAero = powerAtWheel - pRoll - pClimb;
  const denom = 0.5*env.rho*v_air*v_air*v_g;

  if (denom <= 0 || pAero <= 0) return NaN;
  return pAero / denom;
}

function analyseCdAFromRecords(records, env, cfg){
  const cdasAll = [];
  const raceFlat = [];
  const climbRelaxed = [];
  const points = [];

  for (const rec of records){
    if (!isUsableRecord(rec, cfg)) continue;
    const cda = computeCdAForRecord(rec, env);
    if (!isFinite(cda) || cda < cfg.minCdA || cda > cfg.maxCdA) continue;

    const v_kmh = rec.speed*3.6;
    const grade = rec.grade || 0;
    const absGrade = Math.abs(grade);

    const cat = (absGrade <= 0.01) ? "race" : (grade >= 0.02 ? "climb" : "other");

    cdasAll.push(cda);
    if (cat === "race") raceFlat.push({cda, v_kmh});
    if (cat === "climb") climbRelaxed.push({cda, v_kmh});

    if (points.length < 4000){
      points.push({ cda, v_kmh, cat });
    }
  }

  function summarise(list){
    if (!list.length) return {n:0, median:null, p25:null, p75:null};
    const vals = list.map(x => x.cda).slice().sort((a,b)=>a-b);
    const n = vals.length;
    const median = vals[Math.floor(n*0.5)];
    const p25 = vals[Math.floor(n*0.25)];
    const p75 = vals[Math.floor(n*0.75)];
    return {n, median, p25, p75};
  }

  const allSummary = summarise(cdasAll.map(x => ({cda:x})));
  const raceSummary = summarise(raceFlat);
  const climbSummary = summarise(climbRelaxed);

  function summariseHighSpeed(list){
    const filtered = list.filter(p => p.v_kmh >= 24);
    if (!filtered.length) return {n:0, median:null, p25:null, p75:null};
    return summarise(filtered);
  }
  const raceHigh = summariseHighSpeed(raceFlat);
  const climbHigh = summariseHighSpeed(climbRelaxed);

  return {
    countAll: cdasAll.length,
    allSummary,
    raceSummary,
    climbSummary,
    raceHigh,
    climbHigh,
    points
  };
}

function renderFitAnalysis(a, summaryEl, statsTable, statsBody){
  function fmt(v, digits){
    return (v == null || !isFinite(v)) ? "–" : v.toFixed(digits);
  }

  if (!a || !a.countAll){
    summaryEl.textContent = "No usable samples after filtering.";
    statsTable.style.display = "none";
    statsBody.innerHTML = "";
    return;
  }

  const estRace = a.raceHigh.median ?? a.raceSummary.median;
  const estClimb = a.climbHigh.median ?? a.climbSummary.median;

  summaryEl.innerHTML =
    `Estimated <strong>racing CdA</strong> (flat, ≥24 km/h where available): <strong>${fmt(estRace,3)}</strong><br>` +
    `Estimated <strong>climbing / relaxed CdA</strong>: <strong>${fmt(estClimb,3)}</strong><br>` +
    `<span style="font-size:0.9em;color:#555;">${a.countAll} samples used after filtering. ` +
    `Race flat samples: ${a.raceSummary.n}, climb samples: ${a.climbSummary.n}.</span>`;

  const rows = [
    { label: "All usable",              s: a.allSummary,  note: "all grades" },
    { label: "Race / flat",            s: a.raceSummary, note: "|grade| ≤ 1%" },
    { label: "Race / flat, ≥24 km/h",  s: a.raceHigh,    note: "subset of race" },
    { label: "Climb / relaxed",        s: a.climbSummary,note: "grade ≥ 2%" },
    { label: "Climb / relaxed, ≥24 km/h", s: a.climbHigh,note: "subset of climb" }
  ];

  statsBody.innerHTML = "";
  rows.forEach(r => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.label}</td>
      <td>${r.s.n}</td>
      <td>${fmt(r.s.median,3)}</td>
      <td>${fmt(r.s.p25,3)} – ${fmt(r.s.p75,3)}</td>
      <td>${r.note}</td>
    `;
    statsBody.appendChild(tr);
  });
  statsTable.style.display = "table";
}

function renderFitScatter(points){
  const canvas = document.getElementById("fitScatter");
  if (!canvas || !canvas.getContext) return;
  const ctx = canvas.getContext("2d");

  const racePoints = points.filter(p => p.cat === "race").map(p => ({x:p.v_kmh,y:p.cda}));
  const climbPoints = points.filter(p => p.cat === "climb").map(p => ({x:p.v_kmh,y:p.cda}));

  if (fitScatterChart){
    fitScatterChart.destroy();
  }

  fitScatterChart = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        { label: "Race / flat",  data: racePoints,  pointRadius: 2 },
        { label: "Climb / relaxed", data: climbPoints, pointRadius: 2 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { type: "linear", title: {display:true,text:"Speed (km/h)"}, ticks: {stepSize:5} },
        y: { title: {display:true,text:"CdA"}, suggestedMin:0.15, suggestedMax:0.5 }
      },
      plugins: {
        legend: {position:"top"},
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const x = ctx.parsed.x;
              const y = ctx.parsed.y;
              return ` ${x.toFixed(1)} km/h, CdA ${y.toFixed(3)}`;
            }
          }
        }
      }
    }
  });
}
</script>
</body>
</html>
